# 故障自愈的设计理念
---
故障自愈的设计理念主要是围绕着业务实际故障处理的过程来考虑的 主要总结如下：

 * 更强的并发能力 (不断接入新的告警)
 * 性能可水平拓展 (并且可能有更多的告警)
 * 99.99% 高可用 (安心可信赖的告警处理平台)
 * 解耦周边系统 (可随意对接不同平台)
 * 方便搭建部署 (拓展业务，在不同环境搭建)

## 水平拓展的解耦模块

* 分模块，多进程运行

自愈后台通过多进程完成告警处理流程中不同阶段的工作来充分利用系统多核。 自愈流程分为拉取匹配进程，收敛进程，处理进程，事件分析进程，定时任务进程，web 进程，监控进程。

* 对主流程重新设计、优化逻辑实现

进程间使用消息队列通讯。使用 redis 共享缓存数据。 由于不同模块间逻辑解耦，所以无进程间通讯的成本。 同时可以根据不同模块的处理能力调整进程数的比例，充分利用计算资源。

* 性能水平拓展

解耦模块的另一个优点是模块可以分布式部署。 比如两台机器跑拉取模块，四台机器跑收敛模块。同时也达到了水平拓展的能力。

## 高可用的分布式流程

* 模块分布式部署

通过模块解耦将模块部署到不同的机器来达到高可用。

* 队列与缓存的高可用

自愈对 Beanstalk 与 Redis 做了统一的封装。

通过一个封装来实现了连接多个队列或缓存机器。上层统一接口，隐藏细节。

在这个封装内实现了同时写入多份数据，并且随机从一个源读取数据。 并且支持连接验证，失败重连等功能。

* 数据同步

用多队列多缓存的方案会导致进程从队列中会拿到两份相同的消息。

因此自愈利用 mysql 中告警的一个状态字段来作为锁。 进程通过修改字段值来抢锁保证数据不被重复处理。

另一些场景下，以 redis 作为分布式锁来避免重复执行。

* qos异常防御机制

有损服务保证高可用和快速响应。 除了解耦外，消息队列的一个主要功能就是削峰。

任何系统都有其承载上限。 在我们的运算资源一定的情况下，量力而为。

当流入系统的数据量达到系统承载上限的时候。 就有必要触发流量控制，抛弃一部分数据来防止产生雪崩效应。

不同于 web 请求，不同的告警是有区别的。

我们不能“一视同仁”得抛弃掉一部分告警。 而是有选择得根据告警的重要程度来优先保证重要告警能被及时处理。

自愈选择了 Beanstalk 作为系统的消息队列。 很大一部分原因就是看中其可设置消息优先级。

同时其可以设置消息延迟以及 bury 的功能也极为实用。 对于“抛弃”的告警，我们也得保证其至少能通知到用户。

对此自愈有个专门的 collect 模块，相当于自愈流程的精简版。

## 逻辑解耦，业务抽象

* 内部模块的逻辑解耦

模块间的解耦使得自愈能够针对瓶颈水平拓展性能，能够实现高可用的架构。

* 抽象看待依赖的系统

自愈的一个目标是打造一个独立完备的故障分析处理系统。 对于这些功能系统，应该是支持可插拔对接的。

对于不同的告警源，自愈定义了标准的告警格式。 通过编写不同的告警源适配器，使得对于拉取之后的流程能通用处理。

对于配置管理系统，自愈不关心具体属性的含义。 自愈对于所有属性抽象看待，决定怎么使用这些属性也是根据用户的配置。

对于故障恢复根据，自愈以套餐的形式进行封装。 通过组合套餐让用户让用户自行配置逻辑。

* 后台与前端的解耦

自愈在蓝鲸平台上的 APP 只是一个提供给用户的配置平台，提供给后台系统规范的配置数据。

## 随搭随用的独立系统

* 保持系统的简易部署与对系统的掌控力

作为一个小团队，没有太多时间花在运维系统上。 除了保证系统的高可用，还得时刻保持项目的高度自动化。

* 便利的开发环境

除了部署的便利，项目还得是方便测试的。任何人都能通过文档快速得搭建一个本地可运行环境。 对于主要流程必须有可执行的测试用例。

自愈除了自身系统外，在流程中还与许多第三方系统有互动。就比如说 Kafka 队列。 上文提到自愈对队列都进行了一层封装，提供统一的接口。

在这之后，自愈还对队列和缓存纯 python 实现了一个内存版本。 但无法链接上正式队列时，将会用本地内存版本替代， 使得本地开发不产生太多依赖，并且不影响整体流程。

## 构建自己的生态

自愈在实现很多东西的时候都尽可能得解耦，将逻辑与业务解耦，提高代码的复用度。诸如

* 自愈对蓝鲸 ESB 的 SDK 版本 实现了失败重试，异常返回等功能

* 自愈对 cmdb IP 相关属性查询的一个封装 cmdb 查询 for human

* 函数缓存装饰器 能够根据函数名和参数设置redis缓存与内存缓存，有许多可选自定义配置

* redis 锁装饰器 能保证函数一段时间内不被重复调用

* 灰度装饰器 能根据环境灰度应用不同的策略

* 计时装饰器 完成各种计时需求

* 频率限制 通过 redis 的 hset 实现对一段滑动时间窗口的调用频率限制

* extended_json 增加对 datetime、tuple 等类型的 dumps、 loads 支持

* 统一的通知封装 更加人性化的接口，支持 error exception critial 等级别的通知，与防骚扰的收敛

* 定时任务模块 一个独立的模块，依赖于 beanstalk 的 delay，实现定时执行函数的功能

* python写前端 图表可以使用 gygal、plot.ly 等 python 图表库。还实验性得实现一个用 python 写前端表单及布局的项目。
